package mbc2;

import java.util.ArrayList;

public class MoveGenerator {
    public MoveUtils MoveUtils;
    public Config config;

    public MoveGenerator(MoveUtils MoveUtils, Config Config){
        this.MoveUtils = MoveUtils;
        this.config = Config;
    }

    public void getNonCapturePawnMoves(
        int source,
        int squareOffset,
        int ownColour,
        int piece,
        ArrayList<Integer> moveList
    ) {
        /*
        *  Gets non-capture pawn moves on a given square and for a given side.

            The idea is the following:
                - check if pawn can move one square forward.
                    if not, no move is possible and the LHS
                    of the multiplier resolves to zero.
                - check if double pawn push is possible
                - return list of human-readable designations
                    of legal moves
            :Inputs:
                - offset +8 if black else -8
        */
        int promotionOffset = (squareOffset == 8) ? 0 : -6;
        long move = ((1 - (1 & (this.config.OCCUPANCIES[2] >>> (source + squareOffset)))) *
                            (AttacksGenerator.PAWN_MOVES_MASKS[ownColour][source] & ~this.config.OCCUPANCIES[2]));
        while (move != 0) {
            int target = BitBoard.getLSBIndex(move);
            move &= ~Long.lowestOneBit(move);
            if ((target >= 0 && target < 8) || (target >= 56 && target < 64)) {
                // We're promoting the pawn.
                for (int num = 10; num >= 7; num--) {
                    int encodedMove = MoveCoder.encodeMove(source, target, piece, num + promotionOffset, 0, 0, 0, 0);
                    moveList.add(encodedMove);
                }
            } 
            else {
                switch (Math.abs(target - source)) {
                    case 16:
                        /* 
                         * We're making a double pawn push.
                         * Shouldn't we update en passant square here (not doing it yet)?
                         * (this.config.ENPASSANT_SQUARE = config.SQUARES[target_square - offset])
                         */
                        int encodedMove = MoveCoder.encodeMove(source, target, piece, 0, 0, 1, 0, 0);
                        moveList.add(encodedMove);
                        break;
                        
                    default:
                        // Regular pawn push
                        encodedMove = MoveCoder.encodeMove(source, target, piece, 0, 0, 0, 0, 0);
                        moveList.add(encodedMove);
                        break;
                }
            }
        }
    }

    public void getAllPawnMoves(
        long pawnBitboard,
        int squareOffset,
        int ownColour,
        int piece,
        ArrayList<Integer> moveList
    ) {
        /*
         * Generates ALL possible pawn moves for a given side and appends each to 
         * the moveList. Capture moves are generated here while non-capture moves
         * are generated by 'getNonCapturePawnMoves'.
            :Inputs:
                - offset +8 if black else -8
         */
        int promotionOffset = (squareOffset == 8) ? 0 : -6;
        while (pawnBitboard != 0) {
            int source = BitBoard.getLSBIndex(pawnBitboard);
            pawnBitboard &= ~Long.lowestOneBit(pawnBitboard);
            long captures = AttacksGenerator.PAWN_ATTACKS[ownColour][source] & this.config.OCCUPANCIES[ownColour ^ 1];
            // Check en passant capture
            if ((this.config.ENPASSANT_SQUARE != "no_square") && 
                (AttacksGenerator.PAWN_ATTACKS[ownColour][source] & 
                (1L << Config.BOARDSQUARES.get(this.config.ENPASSANT_SQUARE))) != 0) {
                    int encodedMove = MoveCoder.encodeMove(source, 
                                        Config.BOARDSQUARES.get(this.config.ENPASSANT_SQUARE), 
                                        piece, 0, 1, 0, 
                                        1, 0);
                    moveList.add(encodedMove);
                }
            
            while (captures != 0) {
                int target = BitBoard.getLSBIndex(captures);
                captures &= ~Long.lowestOneBit(captures);
                // Check if it's a promotion-capture
                if ((target >= 0 && target < 8) || (target >= 56 && target < 64)) {
                    for (int num = 10; num >= 7; num--) {
                        int encodedMove = MoveCoder.encodeMove(source, target, piece, num + promotionOffset, 1,
                             0, 0, 0);
                        moveList.add(encodedMove);
                    }
                } else {
                    // Regular capture
                    int encodedMove = MoveCoder.encodeMove(source, target, piece, 0, 1, 0, 0, 0);
                    moveList.add(encodedMove);
                }
            }
            // Now we get the non-capture moves for this pawn
            getNonCapturePawnMoves(source, squareOffset, ownColour, piece, moveList);
        }
    }

    public void getNonPawnMoves(
        int source,
        int ownColour,
        long attacks,
        int piece,
        ArrayList<Integer> moveList
    ) {
        long nonCaptureMoves = attacks & ~this.config.OCCUPANCIES[2];
        long captureMoves = attacks & this.config.OCCUPANCIES[ownColour ^ 1];

        // Process non-capture moves
        while (nonCaptureMoves != 0) {
            int target = BitBoard.getLSBIndex(nonCaptureMoves);
            nonCaptureMoves &= ~Long.lowestOneBit(nonCaptureMoves);
            int encodedMove = MoveCoder.encodeMove(source, target, piece, 0, 0, 0, 0, 0);
            moveList.add(encodedMove);
        }
        // Process captures
        while (captureMoves != 0) {
            int target = BitBoard.getLSBIndex(captureMoves);
            captureMoves &= ~Long.lowestOneBit(captureMoves);
            int encodedMove = MoveCoder.encodeMove(source, target, piece, 0, 1, 0, 0, 0);
            moveList.add(encodedMove);            
        }
    }

    public boolean canCastle(char castleToSide, int kingPosition, int opponentColour) {
        /*
         *  :Inputs:
                - castleToSide = 'K' if white else 'k' for kingside castling and 'Q' or 'q' if queenside

            :Outputs:
                - boolean indicating ability to castle to indicated side

            IMPORTANT: This method assumes that castling rights have been set up properly!

            Castling rules: 'Castling is permitted only if neither the king nor the rook
            has previously moved (we're not checking these in this method); the squares
            between the king and the rook are vacant; and the king does not leave (e),
            cross over (d or f), or finish (c or g) on a square attacked by an enemy piece.'

            Source: 'https://en.wikipedia.org/wiki/Castling'
            (Words in parentheses mine)

         */
        boolean isKingSide = Character.toLowerCase(castleToSide) == 'k';
        long emptySquares = isKingSide ? 0b11L : 0b111L;
        int leftShift = isKingSide ? kingPosition + 1 : kingPosition - 3;
        int squareBesideKing = isKingSide ? kingPosition + 1 : kingPosition - 1;

        return (
            (this.config.CASTLING_RIGHT & Config.CASTLING.get(castleToSide)) != 0 && // player has appropriate castling right
            !this.MoveUtils.isKingUnderCheck(kingPosition, opponentColour) &&
            !this.MoveUtils.isSquareAttacked(squareBesideKing, opponentColour) &&    // king isn't crossing an attacked square
            ((emptySquares << leftShift) & this.config.OCCUPANCIES[2]) == 0          // squares between the king and the rook are vacant
        );
    }

    public ArrayList<Integer> generateMoves() {
        /*
         * Generates all moves that can be made by the player
         * whose turn it is to move.
         */
        ArrayList<Integer> moveList = new ArrayList<>();
        char stm = this.config.SIDE_TO_MOVE;
        int ownColour = Config.COLOURS.get(stm);
        // loop over pieces and corresponding bitboards
        for (int idx = 0; idx < 12; idx++) {
            long bitboard = this.config.PIECE_BITBOARDS[idx];
            char piece = Config.ASCII_PIECES[idx];

            // Handle pawn moves
            if (piece == 'p' && stm == 'b') {
                getAllPawnMoves(bitboard, 8, ownColour, idx, moveList);
            }
            else if (piece == 'P' && stm == 'w') {
                getAllPawnMoves(bitboard, -8, ownColour, idx, moveList);
            }

            // Handle king moves
            else if ((piece == 'K' && stm == 'w') || (piece == 'k' && stm == 'b')) {
                // Add castling moves, if possible.
                char queenSide = (piece == 'K') ? 'Q' : 'q';
                int rank = (piece == 'K') ? 1 : 8;
                // Kingside castling
                if (canCastle(piece, Config.BOARDSQUARES.get(String.format("e%d", rank)), ownColour ^ 1)) {
                    int encodedMove = MoveCoder.encodeMove(
                        Config.BOARDSQUARES.get(String.format("e%d", rank)),
                        Config.BOARDSQUARES.get(String.format("g%d", rank)),
                        idx, 0, 0, 0, 0, 1
                    );
                    moveList.add(encodedMove);
                }
                // Queenside castling
                if (canCastle(queenSide, Config.BOARDSQUARES.get(String.format("e%d", rank)), ownColour ^ 1)) {
                    int encodedMove = MoveCoder.encodeMove(
                        Config.BOARDSQUARES.get(String.format("e%d", rank)),
                        Config.BOARDSQUARES.get(String.format("c%d", rank)),
                        idx, 0, 0, 0, 0, 1
                    );
                    moveList.add(encodedMove);
                }
                // Handle other king moves
                while (bitboard != 0) {
                    int source = BitBoard.getLSBIndex(bitboard);
                    bitboard &= ~Long.lowestOneBit(bitboard);
                    long attacks = AttacksGenerator.KING_ATTACKS[source];
                    getNonPawnMoves(source, ownColour, attacks, idx, moveList);
                }
            }
            // Handle knight moves
            else if ((piece == 'N' && stm == 'w') || (piece == 'n' && stm == 'b')) {
                while (bitboard != 0) {
                    int source = BitBoard.getLSBIndex(bitboard);
                    bitboard &= ~Long.lowestOneBit(bitboard);
                    long attacks = AttacksGenerator.KNIGHT_ATTACKS[source];
                    getNonPawnMoves(source, ownColour, attacks, idx, moveList);
                }
            }
            // Handle bishop moves
            else if ((piece == 'B' && stm == 'w') || (piece == 'b' && stm == 'b')) {
                while (bitboard != 0) {
                    int source = BitBoard.getLSBIndex(bitboard);
                    bitboard &= ~Long.lowestOneBit(bitboard);
                    long attacks = AttacksGenerator.getBishopAttacks(source, this.config.OCCUPANCIES[2]);
                    getNonPawnMoves(source, ownColour, attacks, idx, moveList);
                }
            }
            // Handle rook moves
            else if ((piece == 'R' && stm == 'w') || (piece == 'r' && stm == 'b')) {
                while (bitboard != 0) {
                    int source = BitBoard.getLSBIndex(bitboard);
                    bitboard &= ~Long.lowestOneBit(bitboard);
                    long attacks = AttacksGenerator.getRookAttacks(source, this.config.OCCUPANCIES[2]);
                    getNonPawnMoves(source, ownColour, attacks, idx, moveList);
                }
            }
            // Handle queen moves
            else if ((piece == 'Q' && stm == 'w') || (piece == 'q' && stm == 'b')) {
                while (bitboard != 0) {
                    int source = BitBoard.getLSBIndex(bitboard);
                    bitboard &= ~Long.lowestOneBit(bitboard);
                    long attacks = AttacksGenerator.getQueenAttacks(source, this.config.OCCUPANCIES[2]);
                    getNonPawnMoves(source, ownColour, attacks, idx, moveList);
                }
            }
        }
        return moveList;
    }
}
